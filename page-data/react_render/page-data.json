{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/react_render/",
    "result": {"data":{"cur":{"id":"f83e32f5-d0dc-5ed2-b781-c46d019ce40a","html":"<h2 id=\"렌더링이란\" style=\"position:relative;\"><a href=\"#%EB%A0%8C%EB%8D%94%EB%A7%81%EC%9D%B4%EB%9E%80\" aria-label=\"렌더링이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>렌더링이란?</h2>\n<p>리액트 앨리먼트를 html 형태로 변환하여 화면에 그려지는 것</p>\n<h2 id=\"렌더링-이슈\" style=\"position:relative;\"><a href=\"#%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%9D%B4%EC%8A%88\" aria-label=\"렌더링 이슈 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>렌더링 이슈</h2>\n<p>리덕스를 사용해서 state 상태관리를 하는데, setState로 렌더링을 한 번 더 하게하는 코드를 발견했다.<br>\nsetState를 지우니 자식컴포넌트 그리드의 데이터가 바인딩이 되지 않는다. (!?)</p>\n<p><strong>문제의 코드</strong></p>\n<h5 id=\"span-stylecolorblueacomponentspan\" style=\"position:relative;\"><a href=\"#span-stylecolorblueacomponentspan\" aria-label=\"span stylecolorblueacomponentspan permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><span style=\"color:blue\">AComponent</span></h5>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React, { Component } from 'react'; // 기본 react component\r\nimport { connect } from 'react-redux; // redux\r\n\r\nimport * as action from 'bl/action'; // redux - action\r\n\r\n    class CptA extends Component {\r\n\r\n        constructor(props) {\r\n            super(props);\r\n\r\n            this.state = { \r\n                aState: [{}],\r\n                bState: false,\r\n            }\r\n        }\r\n\r\n        functionA = () => {  // functionA가 실행되는 상황이라고 가정\r\n            const { setAB } = this.props.setAB;\r\n\r\n            apiA(apiAParam)\r\n            .then((response) => {\r\n                if(response.resultCode === 200 ){\r\n                    // 아래의 코드를 지우면 자식컴포넌트 그리드의 데이터가 바인딩 되지 않는다(?)\r\n                    this.setState({\r\n                        aState: response.resultData,\r\n                        bState: true\r\n                    });\r\n\r\n                    setAB(response.resultData, true);\r\n\r\n                }\r\n            })\r\n        } \r\n\r\n        render(){\r\n            return(\r\n                {\r\n                    &lt;CptB className= Astate ? 'cptB' : 'cptB_complete'>\r\n                      &lt;CptC> // 데이터 그리드 - 컴포넌트  \r\n                    &lt;/> \r\n                }\r\n            )\r\n        }\r\n    }\r\n\r\n// redux - state 가져오기\r\nlet mapStateToProps = (state) => {\r\n    return {\r\n        aState: state.a_rd.aState,\r\n        bState: state.b_rd.bState\r\n    }\r\n}\r\n\r\n// redux - state 변경\r\nlet mapDispatchToProps = (dispatch) => {\r\n    return {\r\n        setAB: (aState, bState) => dispatch(action.sendPage_act(aState, bState))\r\n    }\r\n}\r\n\r\nCptA = connect(mapStateToProps, mapDispatchToProps)(CptA);\r\nexport default CptA;\r\n</code></pre></div>\n<h2 id=\"-react가-렌더링을-실행할-때\" style=\"position:relative;\"><a href=\"#-react%EA%B0%80-%EB%A0%8C%EB%8D%94%EB%A7%81%EC%9D%84-%EC%8B%A4%ED%96%89%ED%95%A0-%EB%95%8C\" aria-label=\" react가 렌더링을 실행할 때 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🥊 React가 렌더링을 실행할 때</h2>\n<ol>\n<li>\n<p>props가 변경되었을 때</p>\n</li>\n<li>\n<p>state가 변경되었을 때</p>\n</li>\n<li>\n<p>forceUpdate()를 실행하였을 때</p>\n</li>\n<li>\n<p><strong>부모 컴포넌트가 렌더링 되었을 때</strong></p>\n</li>\n</ol>\n<h2 id=\"해결의-과정\" style=\"position:relative;\"><a href=\"#%ED%95%B4%EA%B2%B0%EC%9D%98-%EA%B3%BC%EC%A0%95\" aria-label=\"해결의 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>해결의 과정</h2>\n<blockquote>\n<p>a. 4번과 같이 부모 컴포넌트가 렌더링이 되면, 자식 컴포넌트가 렌더링이 된다고 인지</p>\n</blockquote>\n<p>b. 리덕스 라이브러리를 사용하지 않은 순수 리액트에서만 해당되는 이야기<br>\nc. 리덕스 라이브러리를 사용한 경우는 1~3번만 렌더링이 됨<br>\nd. 현재는 setState로 상태변경이 이뤄져야 자식 컴포넌트에서의 렌더링이 제대로 됨.<br>\ne. setState({ bState: true }) 상태변경을 하면 렌더링이 되고, redux를 통한 상태변경을 하면 렌더링이 안되는 이유</p>\n<blockquote>\n<blockquote>\n<ol>\n<li>bState는 현재 CptC에 영향을 주고있음.</li>\n<li>aState만 setState로 변경한다고하면, 변경되지 않음.</li>\n<li><strong>결론: redux를 통한 상태변경은 CptC에서 데이터 바인딩이 된 그리드를 그릴 수가 없음. 그리드의 오류로밖에 결론이 내려지지 않음.</strong></li>\n<li>너무 억울.. 그리드는 다른 팀에서 제공한 라이브러리임.</li>\n</ol>\n</blockquote>\n</blockquote>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EB%A0%8C%EB%8D%94%EB%A7%81%EC%9D%B4%EB%9E%80\">렌더링이란?</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%9D%B4%EC%8A%88\">렌더링 이슈</a></p>\n<ul>\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#span-stylecolorblueacomponentspan\"><span style=\"color:blue\">AComponent</span></a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-react%EA%B0%80-%EB%A0%8C%EB%8D%94%EB%A7%81%EC%9D%84-%EC%8B%A4%ED%96%89%ED%95%A0-%EB%95%8C\">🥊 React가 렌더링을 실행할 때</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%95%B4%EA%B2%B0%EC%9D%98-%EA%B3%BC%EC%A0%95\">해결의 과정</a></p>\n</li>\n</ul>\n</div>","excerpt":"렌더링이란? 리액트 앨리먼트를 html 형태로 변환하여 화면에 그려지는 것 렌더링 이슈 리덕스를 사용해서 state 상태관리를 하는데, setState로 렌더링을 한 번 더 하게하는 코드를 발견했다. setState를 지우니 자식컴포넌트 그리드의 데이터가 바인딩이 되지 않는다. (!?) 문제의 코드 AComponent 🥊 React가 렌더링을 실행할 때 props가 변경되었을 때 state가 변경되었을 때 forceUpdate()를 실행하였을 때 부모 컴포넌트가 렌더링 되었을 때 해결의 과정 a. 4번과 같이 부모 컴포넌트가 렌더링이 되면, 자식 컴포넌트가 렌더링이 된다고 인지 b. 리덕스 라이브러리를 사용하지 않은 순수 리액트에서만 해당되는 이야기 c. 리덕스 라이브러리를 사용한 경우는 1~3번만 렌더링이 됨 d. 현재는 setState로 상태변경이 이뤄져야 자식 컴포넌트에서의 렌더링이 제대로 됨. e. setState({ bState: true }) 상태변경을 하면 렌더링이 되…","frontmatter":{"date":"January 06, 2022","title":"react | 렌더링을 언제 하길래 데이터 변경이 안돼?","categories":"front","author":"ssongs2","emoji":"🧩"},"fields":{"slug":"/react_render/"}},"next":{"id":"27b255aa-be11-5b55-b84c-2a1a99215fcd","html":"<h2 id=\"얕은-복사shallow-copy\" style=\"position:relative;\"><a href=\"#%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%ACshallow-copy\" aria-label=\"얕은 복사shallow copy permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>얕은 복사(Shallow Copy)</h2>\n<p>객체가 담겨있는 변수를 다른 변수에 할당하면 call by reference (참조)가 일어난다.<br>\n값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복사한다.<br>\n복사된 객체는 원본 객체의 주솟값을 참조하고 있는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const obj = { a: 1, b: 2};\r\nconst objCopy = obj;\r\n\r\nobjCopy.a = 2;\r\n\r\nconsole.log(\"obj === objCopy: \", obj === objCopy); // true\r\nconsole.log(\"obj.a:\", obj.a); // 2</code></pre></div>\n<h2 id=\"깊은-복사deep-copy\" style=\"position:relative;\"><a href=\"#%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%ACdeep-copy\" aria-label=\"깊은 복사deep copy permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>깊은 복사(Deep Copy)</h2>\n<p>독립적인 메모리에 값 자체를 할당하여 생성하는 것으로, 깊은 복사를 통해 원본의 객체와는 다른 고유한 객체를 생성한다.</p>\n<h3 id=\"objectassign\" style=\"position:relative;\"><a href=\"#objectassign\" aria-label=\"objectassign permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Object.assign()</h3>\n<blockquote>\n<h4 id=\"사용법\" style=\"position:relative;\"><a href=\"#%EC%82%AC%EC%9A%A9%EB%B2%95\" aria-label=\"사용법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>사용법</h4>\n</blockquote>\n<p>Object.assign(생성할 객체, 원본 객체) 메서드의 첫 번째 인수로 빈 객체를 넣어주며,\r\n두 번째 인수로 할당할 객체를 넣어준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const obj = { a:1, b: 2};\r\nconst objCopy = Object.assign({}, obj);\r\n\r\nobjCopy.a = 2;\r\n\r\nconsole.log(\"obj === objCopy: \", obj === objCopy); // false\r\nconsole.log(\"obj.a:\", obj.a); // 1\r\n</code></pre></div>\n<h3 id=\"-spread-operator\" style=\"position:relative;\"><a href=\"#-spread-operator\" aria-label=\" spread operator permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>… (Spread Operator)</h3>\n<blockquote>\n<h4 id=\"사용법-1\" style=\"position:relative;\"><a href=\"#%EC%82%AC%EC%9A%A9%EB%B2%95-1\" aria-label=\"사용법 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>사용법</h4>\n</blockquote>\n<p>…연산자를 사용하여 고유한 객체를 생성한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const obj = { a:1, b:2 };\r\nconst objCopy = ...obj;\r\n</code></pre></div>\n<p>깊은 복사의 방법 Object.assign()과 …는 <span style=\"color:red\">1레벨 깊이</span>에서는<br>\n우리의 생각대로 깊은 복사가 가능하지만, <span style=\"color:red\">그 이상 레벨의 복사에서는 아래의 방법을 통해 복사를 진행해야 한다.</span></p>\n<h3 id=\"완벽한-deep-copy를-위한-방법\" style=\"position:relative;\"><a href=\"#%EC%99%84%EB%B2%BD%ED%95%9C-deep-copy%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%B0%A9%EB%B2%95\" aria-label=\"완벽한 deep copy를 위한 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>완벽한 Deep Copy를 위한 방법</h3>\n<p><strong>1. 재귀적으로 깊은 복사를 수행:</strong> 원본 객체의 최고 레벨의 깊이까지 가 복사하는 방법으로 객체의 깊이가 길어질수록 시간복잡도(Time Complexity)가 늘어난다.<br>\n<br />\r\n<strong>2. Lodash의 cloneDeep 함수 수행:</strong>  자바스크립트의 함수형 라이브러리로 Lodash의 cloneDeep함수를 사용하면 완벽하게 깊은 복사를 사용할 수 있다.<br>\n<br />\r\n<strong>3. JSON.parse()와 JSON.stringify()함수 사용:</strong>  문자열로 변환하는 순간 참조 값이 끊기기 때문에 새로운 Object로 만들어서 사용할 수 있음</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%ACshallow-copy\">얕은 복사(Shallow Copy)</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%ACdeep-copy\">깊은 복사(Deep Copy)</a></p>\n<ul>\n<li><a href=\"#objectassign\">Object.assign()</a></li>\n<li><a href=\"#-spread-operator\">… (Spread Operator)</a></li>\n<li><a href=\"#%EC%99%84%EB%B2%BD%ED%95%9C-deep-copy%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%B0%A9%EB%B2%95\">완벽한 Deep Copy를 위한 방법</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"December 17, 2021","title":"js | 얕은 복사? 깊은 복사?","categories":"front","author":"ssongs2","emoji":"🕸"},"fields":{"slug":"/js_copy/"}},"prev":{"id":"f9ade580-7957-5c31-9e1c-390754f47709","html":"<p>누군가 나한테 물어본 질문</p>\n<p>👨🏼‍🦱 : JSX를 쓰면 새로고침이 안되니까 이 JSX를 이용해서 데이터를 묶어둘 수 있지않아?<br>\n🙋🏻‍♀️ : 네??? JSX는 그냥 문법일 뿐인데</p>\n<p>까지 얘기함; 새로고침은 JSX와 관련이 없습니다.하고 SPA를 멋드러지게 설명 하고싶었어요.</p>\n<h2 id=\"spasingle-page-application\" style=\"position:relative;\"><a href=\"#spasingle-page-application\" aria-label=\"spasingle page application permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SPA(Single Page Application)</h2>\n<ul>\n<li>모든 정적 리소스를 최초 접근 시 단 한 번만 다운로드 한다.</li>\n<li>새로운 페이지 요청 시 페이지 갱신에 필요한 데이터만 JSON으로 전달받아 페이지를 갱신한다.</li>\n<li>전체 페이지를 다시 렌더링하지 않고 변경되는 부분만 갱신하므로 새로고침이 발생하지 않는다.</li>\n</ul>\n<p>SPA를 더 자세히 설명하기 위해서는 SPA의 반대인 MPA와 비교하여 설명하면 이해가 쉬울 것 같다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 46.111111111111114%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB6UlEQVQozz2QS2/TQBRG8/9XVLxaAQKEWoHEEtR2hVBVsUNIEAohTRw7iePHPJzY49fMHGQHcaW7OzP3fN9Em56kaJFlxzB/VM5cS8Bj81vc7hJXfEdWlrRo0ObILfaKn1qBM7jsMy65xpcLJrFuWKSGMDfEqUAVB3oHbWuwq9e4+xNs/IFINiwyQ5RXbJMMXRywQFsl2OUZdv4Al98wGexWomEja6qmp3cefTAkyQa3fosPzrC7azaqJRQ1saqp257OOnJdke/msH6DC05x4guTnW6YbRRrYegco11pOna7Nd3qnHr2CLu7Gg1nW82QyHrG1WVLup3RB6+ofz/EDx8OF6eRGh8YY/DOjh3hG5rgnOLHyWg4VDIN0tHQVCVd2xy5LsfMn1NMT/ByMNx3rIKITRghkpjuoKCt8Ubiogt8cPo/8lDNVpSIOKLZC3zb4PYhLnyFXz49Rk4yxbeP75jfXEHfQl9zkDlx8AsXnWMXT7C7S9aq5W6aEYUKbHPklEJs7/DhS+z9Y5y4ZZLuW5bzBds4G3vx3tP1lkMh6dfvccEzbPaJre5YJiWJrnHO4ZzFDYlrgQ0vsMELvPrKpDI1qdQIpZFSjqukpCgK8nRDtc/A9xzKijTLEf8YIQRKKbSSI9dUCrzlL1btoYhpZLJTAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"webpage-lifecycle.png\"\n        title=\"webpage-lifecycle.png\"\n        src=\"/static/b4724400ebb2e13e7dd1972d24706255/37523/webpage-lifecycle.png\"\n        srcset=\"/static/b4724400ebb2e13e7dd1972d24706255/e9ff0/webpage-lifecycle.png 180w,\n/static/b4724400ebb2e13e7dd1972d24706255/f21e7/webpage-lifecycle.png 360w,\n/static/b4724400ebb2e13e7dd1972d24706255/37523/webpage-lifecycle.png 720w,\n/static/b4724400ebb2e13e7dd1972d24706255/71c8e/webpage-lifecycle.png 875w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2 id=\"mpamulti-page-application\" style=\"position:relative;\"><a href=\"#mpamulti-page-application\" aria-label=\"mpamulti page application permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MPA(Multi Page Application)</h2>\n<ul>\n<li>새로운 페이지 요청 시 페이지 갱신에 필요한 완전한 리소스를 클라이언트에 응답한다.</li>\n<li>응답을 받아, 렌더링하는 과정에서 새로고침이 발생한다.</li>\n<li>각 페이지마다 고유의 URL이 존재한다.</li>\n</ul>\n<blockquote>\n</blockquote>\n<p>즉, 과거의 웹사이트는 MPA로 이루어져있고, 요즘의 웹사이트는 SPA로 이루어져있다.<br>\n첫 화면 로드 시 서버로부터 모든 정적 리소스를 다운로드 받아<br>\n이벤트가 발생하거나 페이지가 변경될 시에는 최초에 로드된 자바스크립트를 통해 변경이 이루어지는 것이다.</p>\n<h2 id=\"spa의-라우팅\" style=\"position:relative;\"><a href=\"#spa%EC%9D%98-%EB%9D%BC%EC%9A%B0%ED%8C%85\" aria-label=\"spa의 라우팅 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SPA의 라우팅</h2>\n<h4 id=\"-라우팅이란\" style=\"position:relative;\"><a href=\"#-%EB%9D%BC%EC%9A%B0%ED%8C%85%EC%9D%B4%EB%9E%80\" aria-label=\" 라우팅이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>🙊 라우팅이란</strong></h4>\n<p>사용자가 요청한 URL을 해석하고 새로운 페이지를 전환하기 위한 데이터를 취득하기 위해 데이터를 서버에 요청하고 화면을 전환하는 일련의 행위를 말함.</p>\n<ol>\n<li>Ajax</li>\n</ol>\n<p>비동기적으로 서버와 브라우저가 데이터를 교환할 수 있는 통신방식</p>\n<ol start=\"2\">\n<li>Hash</li>\n</ol>\n<p>url의 hash가 변경되면 발생하는 hashchange 이벤트를 사용하여 ajax 요청을 수행</p>\n<h4 id=\"-spa에-라우팅이-왜나와\" style=\"position:relative;\"><a href=\"#-spa%EC%97%90-%EB%9D%BC%EC%9A%B0%ED%8C%85%EC%9D%B4-%EC%99%9C%EB%82%98%EC%99%80\" aria-label=\" spa에 라우팅이 왜나와 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>🙊 SPA에 라우팅이 왜나와?</strong></h4>\n<p>라우팅 시<br>\n서버에서 페이지를 응답받아 화면을 렌더링을 할지(서버 사이드 렌더링),<br>\n브라우저에서 자바스크립트를 활용해 화면을 렌더링할지(클라이언트 사이드 렌더링.)<br>\n어떤 렌더링을 하느냐로 MPA(서버 사이드), SPA(클라이언트 사이드)를 구분할 수 있기 때문이죠.</p>","frontmatter":{"date":"January 11, 2022","title":"js | SPA는 뭐야뭐야뭐야뭐야~?","categories":"front","author":"ssongs2","emoji":"🕸"},"fields":{"slug":"/js_spa/"}},"site":{"siteMetadata":{"siteUrl":"https://Ssongs2.github.io","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/react_render/","nextSlug":"/js_copy/","prevSlug":"/js_spa/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}